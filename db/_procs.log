\i procs/000_preprocs.sql
--preprocs
\i procs/010_CreateProc_CrossTableCache.sql
CREATE OR REPLACE FUNCTION cross_table_cache_sq(alreadyAuth_ text, securityuserid_ text, sessionid_ text)
  RETURNS SETOF type_label_value AS
$BODY$
  Declare
  queryStr text;
    
  Begin
    if alreadyAuth_ <>'ALREADY_AUTH' then
    	perform isSessionValid( securityuserId_,sessionId_) ;
    	perform isUserAuthorized( securityuserId_, 'SELECT_CROSS_TABLE_CACHE' );
    end if;
    queryStr='select ''golfer''::varchar as tp, name as lbl, golfer_id::varchar as val from golfer   ';
    queryStr= queryStr || 'union select ''securityProfile''::varchar as tp, profile_name as lbl, security_profile_id::varchar as val from security_profile ';
    return query execute queryStr;	

  End;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100
  ROWS 1000;
CREATE FUNCTION
\i procs/020_CreateProc_GolferHandicap.sql
create or replace function golfer_handicap_sq(alreadyAuth_ text, securityuserid_ text, sessionid_ text) returns setof golfer_summary as
$BODY$
  Declare
  result golfer_summary;
  golfers golfer;
  Begin
  if alreadyAuth_ <>'ALREADY_AUTH' then
    	perform isSessionValid( securityuserId_,sessionId_) ;
    	perform isUserAuthorized( securityuserId_, 'SELECT_GOLFER_HANDICAP' );
    end if;
  for golfers in select * from golfer order by name loop
    select golfers.golfer_id, golfers.name,  avg(golf_score) as avg_score, 
      max(game_dt) as last_date, min(game_dt) as first_date  into result from (
	select golf_score, game_dt from golf_score
	where golfer_id =golfers.golfer_id order by last_update desc limit 10) as temp1 ; 
	 return next result;
  end loop;
  return;
  end; 
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100
  ROWS 1000;
CREATE FUNCTION
\i procs/030_CreateProc_CRUD_golfer.sql
-- Function: golfer_sq(text, text, text, text, text, integer, integer)
-- DROP FUNCTION golfer_sq(text, text, text, text, text, integer, integer);
CREATE OR REPLACE FUNCTION golfer_sq(alreadyAuth_ text, securityuserid_ text, sessionid_ text, whereClause_ text, orderByClause_ text, rowLimit_ integer, rowOffset_ integer)
  RETURNS SETOF golfer AS
$BODY$
  Declare
   Begin
    if alreadyAuth_ <>'ALREADY_AUTH' then
    	perform isSessionValid( securityuserId_,sessionId_) ;
    	perform isUserAuthorized( securityuserId_, 'SELECT_GOLFER' );
    end if;
    return query execute 'select * from golfer ' ||  buildSQLClauses(whereClause_,orderByClause_,rowLimit_,rowOffset_);  
  End;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100
  ROWS 1000;
CREATE FUNCTION
--ALTER FUNCTION golfer_sq(text,  text, text, text, text, integer, integer) OWNER TO postgres;
--GRANT EXECUTE ON FUNCTION golfer_sq(text, text, text, text, text, integer, integer) TO GROUP golfscore;
--select * from golfer_sq('ALREADY_AUTH',  'test', 'test', '','',-1,-1);
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function: golfer_bypk(text, text, text ,integer)
-- DROP FUNCTION golfer_pybk(text, text, text,integer);
--CREATE OR REPLACE FUNCTION golfer_bypk(alreadyAuth_ text,  securityuserid_ text, sessionid_ text 
--,golferId_ integer)
--  RETURNS golfer AS
--$BODY$
--  Declare
--    result golfer;
--  Begin
--    if alreadyAuth_ <>'ALREADY_AUTH' then
--    	perform isSessionValid( securityuserId_,sessionId_) ;
--    	perform isUserAuthorized( securityuserId_, 'SELECT_GOLFER' );
--    end if;
--golfer_id, last_update, updated_by, name
--     select * into result from golfer where golfer_id=golferId_;
--     return result;
--  End;
--$BODY$
--  LANGUAGE 'plpgsql' VOLATILE
--  COST 100;
--ALTER FUNCTION golfer_bypk(text,  text, text,integer) OWNER TO postgres;
--GRANT EXECUTE ON FUNCTION golfer_bypk(text,  text, text,integer) TO GROUP golfscore;
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function:  golfer_iq(text, text, text ,character varying)
-- DROP FUNCTION golfer_iq( text, text, text,character varying);
create or replace function golfer_iq(alreadyauth_ text, securityuserid_ text, sessionid_ text,name_ character varying)
  returns golfer as
$body$
  declare
    newrow golfer;
  begin
    if alreadyauth_ <>'ALREADY_AUTH' then	
    	perform issessionvalid( securityuserid_,sessionid_) ;
    	perform isuserauthorized( securityuserid_,'INSERT_GOLFER' );
    end if;


    insert into golfer( last_update,updated_by,name)  values (  now(), securityuserid_,name_) 
	returning * into newrow;
      return newrow;
  end;
$body$
  language 'plpgsql' volatile
  cost 100;
CREATE FUNCTION
--alter function golfer_iq(text,  text, text ,character varying) owner to postgres;
--GRANT EXECUTE ON FUNCTION golfer_iq(text,  text, text ,character varying) TO GROUP golfscore;
--select * from golfer_iq('ALREADY_AUTH', 'test', 'test' , 'text', 'text' );
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function:  golfer_uq(text, text, text ,integer,timestamp,character varying)
-- DROP FUNCTION golfer_uq(text, text, text ,integer,timestamp,character varying);
create or replace function golfer_uq(alreadyauth_ text,  securityuserid_ text, sessionid_ text , golferId_ integer, lastUpdate_ timestamp, name_ character varying)
  returns golfer as
$body$
  declare
    updatedrow golfer;
  begin
    if alreadyauth_ <>'ALREADY_AUTH' then	
    	perform issessionvalid( securityuserid_,sessionid_) ;
    	perform isuserauthorized( securityuserid_, 'UPDATE_GOLFER' );
    end if;
	update golfer set last_update = now() , updated_by = securityuserid_,  name= name_ 	where golfer_id=golferId_   and   last_update = lastUpdate_
	returning * into updatedrow;

	if found then
	  return updatedrow;
	else 
	  raise exception 'Update Failed for GOLFER- The record may have been changed or deleted before the attempt.';
	end if;

  end;
$body$
  language 'plpgsql' volatile
  cost 100;
CREATE FUNCTION
--alter function golfer_uq(text,  text, text ,integer,timestamp,character varying) owner to postgres;
--GRANT EXECUTE ON FUNCTION golfer_uq(text, text, text ,integer,timestamp,character varying) TO GROUP golfscore;
--select * from golfer_uq('ALREADY_AUTH', 'test', 'test' <last_update>, 'text', 'text' <golfer_id>);
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function:  golfer_dq(text, text ,integer, timestamp)
-- DROP FUNCTION golfer_dq( text,  text ,integer, timestamp);
create or replace function golfer_dq(alreadyauth_ text,  userid_ text, sessionid_ text ,golferId_ integer, lastUpdate_ timestamp  )
  returns boolean as
$body$
  declare
    
  begin
    if alreadyauth_ <>'ALREADY_AUTH' then	
    	perform issessionvalid( userid_,sessionid_) ;
    	perform isuserauthorized(userid_,'DELETE_GOLFER' );
    end if;
	delete from golfer where golfer_id=golferId_  and last_update = lastUpdate_;

	if found then
	  return true;
	else 
	  raise exception 'Delete Failed for GOLFER- The record may have been changed or deleted before the attempt.';
	end if;
  end;
$body$
  language 'plpgsql' volatile
  cost 100;
CREATE FUNCTION
--alter function golfer_dq(text, text, text,integer, timestamp) owner to postgres;
--GRANT EXECUTE ON FUNCTION golfer_dq(text,  text, text,integer, timestamp) TO GROUP golfscore;
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function:  golfer_dqw(text, text, text)
-- DROP FUNCTION golfer_dqw( text,text,text);
create or replace function golfer_dqw(alreadyauth_ text,  userid_ text, sessionid_ text , whereClause_ text )
  returns boolean as
$body$
  declare
  rcnt int;  
  begin
    if alreadyauth_ <>'ALREADY_AUTH' then	
    	perform issessionvalid( userid_,sessionid_) ;
    	perform isuserauthorized(userid_,'DELETE_GOLFER' );
    end if;
	execute  'delete from golfer ' ||  buildSQLClauses(whereClause_,'',0,0)  ;
	GET DIAGNOSTICS rcnt = ROW_COUNT;
	if rcnt>0 then
	  return true;
	else 
	  raise exception 'Delete Failed for GOLFER- The record may have been changed or deleted before the attempt.';
	end if;
  end;
$body$
  language 'plpgsql' volatile
  cost 100;
CREATE FUNCTION
--alter function golfer_dq(text, text, text,integer, timestamp) owner to postgres;
--GRANT EXECUTE ON FUNCTION golfer_dq(text,  text, text,integer, timestamp) TO GROUP golfscore;
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
\i procs/040_CreateProc_CRUD_golf_score.sql
-- Function: golf_score_sq(text, text, text, text, text, integer, integer)
-- DROP FUNCTION golf_score_sq(text, text, text, text, text, integer, integer);
CREATE OR REPLACE FUNCTION golf_score_sq(alreadyAuth_ text, securityuserid_ text, sessionid_ text, whereClause_ text, orderByClause_ text, rowLimit_ integer, rowOffset_ integer)
  RETURNS SETOF golf_score AS
$BODY$
  Declare
   Begin
    if alreadyAuth_ <>'ALREADY_AUTH' then
    	perform isSessionValid( securityuserId_,sessionId_) ;
    	perform isUserAuthorized( securityuserId_, 'SELECT_GOLF_SCORE' );
    end if;
    return query execute 'select * from golf_score ' ||  buildSQLClauses(whereClause_,orderByClause_,rowLimit_,rowOffset_);  
  End;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100
  ROWS 1000;
CREATE FUNCTION
--ALTER FUNCTION golf_score_sq(text,  text, text, text, text, integer, integer) OWNER TO postgres;
--GRANT EXECUTE ON FUNCTION golf_score_sq(text, text, text, text, text, integer, integer) TO GROUP golfscore;
--select * from golf_score_sq('ALREADY_AUTH',  'test', 'test', '','',-1,-1);
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function: golf_score_bypk(text, text, text ,integer)
-- DROP FUNCTION golf_score_pybk(text, text, text,integer);
--CREATE OR REPLACE FUNCTION golf_score_bypk(alreadyAuth_ text,  securityuserid_ text, sessionid_ text 
--,golfScoreId_ integer)
--  RETURNS golf_score AS
--$BODY$
--  Declare
--    result golf_score;
--  Begin
--    if alreadyAuth_ <>'ALREADY_AUTH' then
--    	perform isSessionValid( securityuserId_,sessionId_) ;
--    	perform isUserAuthorized( securityuserId_, 'SELECT_GOLF_SCORE' );
--    end if;
--golf_score_id, last_update, updated_by, golf_score, golfer_id, game_dt
--     select * into result from golf_score where golf_score_id=golfScoreId_;
--     return result;
--  End;
--$BODY$
--  LANGUAGE 'plpgsql' VOLATILE
--  COST 100;
--ALTER FUNCTION golf_score_bypk(text,  text, text,integer) OWNER TO postgres;
--GRANT EXECUTE ON FUNCTION golf_score_bypk(text,  text, text,integer) TO GROUP golfscore;
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function:  golf_score_iq(text, text, text ,integer,integer,date)
-- DROP FUNCTION golf_score_iq( text, text, text,integer,integer,date);
create or replace function golf_score_iq(alreadyauth_ text, securityuserid_ text, sessionid_ text,golfScore_ integer,golferId_ integer,gameDt_ date)
  returns golf_score as
$body$
  declare
    newrow golf_score;
  begin
    if alreadyauth_ <>'ALREADY_AUTH' then	
    	perform issessionvalid( securityuserid_,sessionid_) ;
    	perform isuserauthorized( securityuserid_,'INSERT_GOLF_SCORE' );
    end if;


    insert into golf_score( last_update,updated_by,golf_score,golfer_id,game_dt)  values (  now(), securityuserid_,golfScore_,golferId_,gameDt_) 
	returning * into newrow;
      return newrow;
  end;
$body$
  language 'plpgsql' volatile
  cost 100;
CREATE FUNCTION
--alter function golf_score_iq(text,  text, text ,integer,integer,date) owner to postgres;
--GRANT EXECUTE ON FUNCTION golf_score_iq(text,  text, text ,integer,integer,date) TO GROUP golfscore;
--select * from golf_score_iq('ALREADY_AUTH', 'test', 'test' , 'text' ,1 ,1, 'text' );
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function:  golf_score_uq(text, text, text ,integer,timestamp,integer,integer,date)
-- DROP FUNCTION golf_score_uq(text, text, text ,integer,timestamp,integer,integer,date);
create or replace function golf_score_uq(alreadyauth_ text,  securityuserid_ text, sessionid_ text , golfScoreId_ integer, lastUpdate_ timestamp, golfScore_ integer, golferId_ integer, gameDt_ date)
  returns golf_score as
$body$
  declare
    updatedrow golf_score;
  begin
    if alreadyauth_ <>'ALREADY_AUTH' then	
    	perform issessionvalid( securityuserid_,sessionid_) ;
    	perform isuserauthorized( securityuserid_, 'UPDATE_GOLF_SCORE' );
    end if;
	update golf_score set last_update = now() , updated_by = securityuserid_,  golf_score= golfScore_ ,  golfer_id= golferId_ ,  game_dt= gameDt_ 	where golf_score_id=golfScoreId_   and   last_update = lastUpdate_
	returning * into updatedrow;

	if found then
	  return updatedrow;
	else 
	  raise exception 'Update Failed for GOLF_SCORE- The record may have been changed or deleted before the attempt.';
	end if;

  end;
$body$
  language 'plpgsql' volatile
  cost 100;
CREATE FUNCTION
--alter function golf_score_uq(text,  text, text ,integer,timestamp,integer,integer,date) owner to postgres;
--GRANT EXECUTE ON FUNCTION golf_score_uq(text, text, text ,integer,timestamp,integer,integer,date) TO GROUP golfscore;
--select * from golf_score_uq('ALREADY_AUTH', 'test', 'test', 'text' <golf_score_id> <last_update> ,1, 'text' ,1);
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function:  golf_score_dq(text, text ,integer, timestamp)
-- DROP FUNCTION golf_score_dq( text,  text ,integer, timestamp);
create or replace function golf_score_dq(alreadyauth_ text,  userid_ text, sessionid_ text ,golfScoreId_ integer, lastUpdate_ timestamp  )
  returns boolean as
$body$
  declare
    
  begin
    if alreadyauth_ <>'ALREADY_AUTH' then	
    	perform issessionvalid( userid_,sessionid_) ;
    	perform isuserauthorized(userid_,'DELETE_GOLF_SCORE' );
    end if;
	delete from golf_score where golf_score_id=golfScoreId_  and last_update = lastUpdate_;

	if found then
	  return true;
	else 
	  raise exception 'Delete Failed for GOLF_SCORE- The record may have been changed or deleted before the attempt.';
	end if;
  end;
$body$
  language 'plpgsql' volatile
  cost 100;
CREATE FUNCTION
--alter function golf_score_dq(text, text, text,integer, timestamp) owner to postgres;
--GRANT EXECUTE ON FUNCTION golf_score_dq(text,  text, text,integer, timestamp) TO GROUP golfscore;
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
-- Function:  golf_score_dqw(text, text, text)
-- DROP FUNCTION golf_score_dqw( text,text,text);
create or replace function golf_score_dqw(alreadyauth_ text,  userid_ text, sessionid_ text , whereClause_ text )
  returns boolean as
$body$
  declare
  rcnt int;  
  begin
    if alreadyauth_ <>'ALREADY_AUTH' then	
    	perform issessionvalid( userid_,sessionid_) ;
    	perform isuserauthorized(userid_,'DELETE_GOLF_SCORE' );
    end if;
	execute  'delete from golf_score ' ||  buildSQLClauses(whereClause_,'',0,0)  ;
	GET DIAGNOSTICS rcnt = ROW_COUNT;
	if rcnt>0 then
	  return true;
	else 
	  raise exception 'Delete Failed for GOLF_SCORE- The record may have been changed or deleted before the attempt.';
	end if;
  end;
$body$
  language 'plpgsql' volatile
  cost 100;
CREATE FUNCTION
--alter function golf_score_dq(text, text, text,integer, timestamp) owner to postgres;
--GRANT EXECUTE ON FUNCTION golf_score_dq(text,  text, text,integer, timestamp) TO GROUP golfscore;
--=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
\i procs/999_postprocs.sql
--postprocs
