\i securitySchema/000_preSecuritySchema.sql
begin;
BEGIN
--before running other Security Schema files
commit;
COMMIT
\i securitySchema/001_CreateSecurityProfile.sql
begin;
BEGIN
drop table if exists security_profile cascade;
psql:securitySchema/001_CreateSecurityProfile.sql:2: NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to constraint fk_security_user_2 on table security_user
drop cascades to constraint fk_security_profile_grant_2 on table security_profile_grant
drop cascades to view vw_profile_grant
drop cascades to view vw_user_grant
DROP TABLE
CREATE TABLE security_profile
(
  security_profile_id serial NOT NULL,
  profile_name text,
  last_update timestamp(3) without time zone,
  updated_by text,
  CONSTRAINT security_profile_pkey PRIMARY KEY (security_profile_id)
)
WITH (
  OIDS=FALSE
);
psql:securitySchema/001_CreateSecurityProfile.sql:13: NOTICE:  CREATE TABLE will create implicit sequence "security_profile_security_profile_id_seq" for serial column "security_profile.security_profile_id"
psql:securitySchema/001_CreateSecurityProfile.sql:13: NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "security_profile_pkey" for table "security_profile"
CREATE TABLE
commit;
COMMIT
\i securitySchema/002_CreateSecurityUser.sql
begin;
BEGIN
DROP TABLE  if exists SECURITY_USER cascade;
psql:securitySchema/002_CreateSecurityUser.sql:2: NOTICE:  drop cascades to function initsession(text,text,text,text)
DROP TABLE
CREATE TABLE security_user
(
  user_id text NOT NULL,
  last_update timestamp(3) without time zone,
  updated_by text,
  password_enc text,
  security_profile_id integer NOT NULL,
  session_id text,
  session_expire_dt timestamp(3) without time zone,
  active_yn character(1),
  CONSTRAINT security_user_pkey PRIMARY KEY (user_id),
  CONSTRAINT fk_security_user_2 FOREIGN KEY (security_profile_id)
      REFERENCES security_profile (security_profile_id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
)
WITH (
  OIDS=FALSE
);
psql:securitySchema/002_CreateSecurityUser.sql:20: NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "security_user_pkey" for table "security_user"
CREATE TABLE
commit;
COMMIT
\i securitySchema/003_CreateSecurityPrivilege.sql
begin;
BEGIN
drop TABLE if exists security_privilege cascade;
psql:securitySchema/003_CreateSecurityPrivilege.sql:2: NOTICE:  drop cascades to constraint fk_securityprofilegrant_securityprivilege on table security_profile_grant
DROP TABLE
CREATE TABLE security_privilege
(
  security_privilege_id int4 NOT NULL,
  priv_name text,
  description text,
  last_update timestamp(3) without time zone,
  updated_by text,
  CONSTRAINT security_privilege_pkey PRIMARY KEY (security_privilege_id)
)
WITH (
  OIDS=FALSE
);
psql:securitySchema/003_CreateSecurityPrivilege.sql:14: NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "security_privilege_pkey" for table "security_privilege"
CREATE TABLE
commit;
COMMIT
\i securitySchema/004_CreateSecurityProfileGrant.sql
begin;
BEGIN
drop table if exists security_profile_grant cascade;
DROP TABLE
CREATE TABLE security_profile_grant
(
  security_privilege_id integer NOT NULL,
  security_profile_id integer NOT NULL,
  last_update timestamp(3) with time zone,
  updated_by text,
  CONSTRAINT security_profile_grant_pkey PRIMARY KEY (security_privilege_id, security_profile_id),
  CONSTRAINT fk_security_profile_grant_2 FOREIGN KEY (security_profile_id)
      REFERENCES security_profile (security_profile_id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT fk_securityprofilegrant_securityprivilege FOREIGN KEY (security_privilege_id)
      REFERENCES security_privilege (security_privilege_id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
)
WITH (
  OIDS=FALSE
);
psql:securitySchema/004_CreateSecurityProfileGrant.sql:19: NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "security_profile_grant_pkey" for table "security_profile_grant"
CREATE TABLE
commit;
COMMIT
\i securitySchema/005_CreateVw_ProfileGrant.sql
begin;
BEGIN
CREATE OR REPLACE VIEW vw_profile_grant AS 
 SELECT sp.security_profile_id, sp.profile_name, spriv.security_privilege_id, spriv.priv_name, spg.last_update
   FROM security_profile sp
   LEFT JOIN security_profile_grant spg ON sp.security_profile_id = spg.security_profile_id
   LEFT JOIN security_privilege spriv ON spg.security_privilege_id = spriv.security_privilege_id;
CREATE VIEW
commit;
COMMIT
\i securitySchema/006_CreateVw_UserGrant.sql
begin;
BEGIN
CREATE OR REPLACE VIEW vw_user_grant AS 
 SELECT su.user_id, sp.profile_name, spriv.priv_name
   FROM security_user su
   LEFT JOIN security_profile sp ON su.security_profile_id = sp.security_profile_id
   LEFT JOIN security_profile_grant spg ON sp.security_profile_id = spg.security_profile_id
   LEFT JOIN security_privilege spriv ON spg.security_privilege_id = spriv.security_privilege_id;
CREATE VIEW
commit;
COMMIT
\i securitySchema/010_CreateSP_InitSession.sql
begin;
BEGIN
CREATE OR REPLACE FUNCTION initsession(checkauthdummyplaceholder text, userid_ text, sessiondummyplaceholder text, password_ text)
  RETURNS security_user AS
$BODY$
 Declare
	sessionId_  character varying;
	securityUser security_user;
 Begin
  sessionId_ := to_hex(((random() * 1000)^3)::Integer ) || to_hex(((random() * 1000)^3)::Integer )
	|| to_hex(((random() * 1000)^3)::Integer )  || to_hex(((random() * 1000)^3)::Integer );
  update security_user 
  set session_id =sessionId_ , session_expire_dt = now()+ '20 min'
  where user_id = userID_ 
    and password_enc = md5(password_);
  if found then
  select * into securityUser from security_user where user_id =  userID_;
    
  else 
    securityUser.user_id :='';
    securityUser.session_id='';
  end if;
  return securityUser ;
 End;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
commit;
COMMIT
\i securitySchema/011_CreateSP_IsSessionValid.sql
begin;
BEGIN
CREATE OR REPLACE FUNCTION issessionvalid(userid_ text, sessionid_ text)
  RETURNS text AS
$BODY$
Declare
    
Begin

  update security_user 
  set session_expire_dt = now() + '20 min'
  where user_id = userID_ 
    and session_id = sessionId_ and session_id is not null and session_id !='';
  if found then
    return 'Valid Session' ;
  else 
    raise exception 'Session Invalid -- Access Denied';
    --return 'Session Invalid -- Access Denied';
  end if;

End;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
commit;
COMMIT
\i securitySchema/012_CreateSP_IsUserAuthorized.sql
begin;
BEGIN
CREATE OR REPLACE FUNCTION isuserauthorized(userid_ text, tran_ text)
  RETURNS boolean AS
$BODY$
Declare
  rowCount integer;
 Begin
   select count(*) into rowCount 
   from vw_user_grant 
   where  user_id =userId_ and priv_name = tran_;
   
   if rowCount <> 1 then
	--raise exception 'ACCESS DENIED-- user is not authorized for this transaction';
    return false;
   end if;
   return true;
 End;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
CREATE FUNCTION
commit;
COMMIT
